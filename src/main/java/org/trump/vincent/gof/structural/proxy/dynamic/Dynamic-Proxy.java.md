## java 动态代理的实现方式
<a href="http://www.jasongj.com/design_pattern/dynamic_proxy_cglib/"> 参考文献</a>
<br/>
<br/>

```$xslt
    代理模式需要为接口实现的每一个实现类构建代理类；
    
    使用动态代理，不再手动为每个实现类构建代理；
    而是在运行时，自动生成代理类的实现。
```
```$xslt
    Notice:
    动态代理，实质是利用工具于运行时生成目标代理类的字节码，并由此构造了代理类的Class对象
    （代理类一定实现了目标的抽象接口），所以，我们用接口声明代理类变量，并由Proxy + Handler构建代理类实例。
```

### 一、JDK动态代理

### 二、cglib

### 三、JDK动态代理 VS cglib代理实现
```$xslt
PRE:
字节码创建方式：JDK动态代理通过JVM实现代理类字节码的创建，cglib通过ASM创建字节码
```
####1、代理类的生成速度
```$xslt
    两者使用不同的字节码生成工具；
    JDK动态代理创建代理对象速度比cglib快
```
####2、生成的代理类的执行速度
```$xslt
    因为，两者使用不同的字节码generator，生成的Class对象自然有所区别；
    一般来讲，cglib方式产出的代理类实例的执行速率要比 JDK动态代理产出的代理类实例的执行速率更快
    （但，也有测试说，JDK动态代理代理对象执行速度比cglib快）
    
```
####3、适用场景
```$xslt
    Spring-AOP 中既使用了JDK动态代理方式，也使用了CgLib；
    
    JDK动态代理只适用于为 以实现接口进行扩展的类 生成代理类；
    
    而，cglib是针对类设计的，其基本作用是为指定类生成一个子类（进行produce代理类只是一个用法），
        cglib以覆盖类中方法的方式为类产出一个子类，（即，代理类也是通过override的方式覆盖了代理目标中的方法），
        由于cglib是继承和override的设计思想，所以要代理的目标方法不能是final声明。
```
